# GENERATED BY KOMAND SDK - DO NOT EDIT
import komand
import json


class Component:
    DESCRIPTION = "Updates the values of given parameters in the given content rule"


class Input:
    COMMENTS = "comments"
    COOKIE_AGE = "cookie_age"
    EXTENDED_MATCH = "extended_match"
    EXTENDED_MATCH_SEQUENCE = "extended_match_sequence"
    FAILOVER_METHOD = "failover_method"
    HEADER_NAME = "header_name"
    HOST_MATCH = "host_match"
    ID = "id"
    LB_ALGORITHM = "lb_algorithm"
    PARAMETER_NAME = "parameter_name"
    PERSISTENCE_COOKIE_DOMAIN = "persistence_cookie_domain"
    PERSISTENCE_COOKIE_NAME = "persistence_cookie_name"
    PERSISTENCE_COOKIE_PATH = "persistence_cookie_path"
    PERSISTENCE_IDLE_TIMEOUT = "persistence_idle_timeout"
    PERSISTENCE_METHOD = "persistence_method"
    SOURCE_IP_NETMASK = "source_ip_netmask"
    STATUS = "status"
    URL_MATCH = "url_match"
    VIRTUAL_SERVICE_ID = "virtual_service_id"
    WEB_FIREWALL_POLICY = "web_firewall_policy"
    

class Output:
    ID = "id"
    

class UpdateContentRuleInput(komand.Input):
    schema = json.loads("""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "comments": {
      "type": "string",
      "title": "Comments",
      "description": "Description about the content rule",
      "order": 20
    },
    "cookie_age": {
      "type": "integer",
      "title": "Cookie Age",
      "description": "The expiry age of the persistence cookie in minutes",
      "order": 17
    },
    "extended_match": {
      "type": "string",
      "title": "Extended Match",
      "description": "An expression that consists of a combination of HTTP headers and/or query string parameters",
      "order": 8
    },
    "extended_match_sequence": {
      "type": "integer",
      "title": "Extended Match Sequence",
      "description": "A number to indicate the order in which the extended match rule must be evaluated in the requests",
      "order": 9
    },
    "failover_method": {
      "type": "string",
      "title": "Failover Method",
      "description": "The failover method to be used when responding to a request which is persistent, but the server that must serve the request is failed or set to 'Out-of-Service'",
      "order": 11
    },
    "header_name": {
      "type": "string",
      "title": "Header Name",
      "description": "The name of the header for which the value needs to be checked in the HTTP requests",
      "order": 18
    },
    "host_match": {
      "type": "string",
      "title": "Host Match",
      "description": "A host name to be matched against the host in the request header",
      "order": 6
    },
    "id": {
      "type": "string",
      "title": "ID",
      "description": "Content rule ID",
      "order": 2
    },
    "lb_algorithm": {
      "type": "string",
      "title": "Load Balancing Algorithm",
      "description": "The algorithm to be used for load balancing",
      "enum": [
        "round_robin",
        "weighted_round_robin",
        "least_requests"
      ],
      "order": 3
    },
    "parameter_name": {
      "type": "string",
      "title": "Parameter Name",
      "description": "The name of the parameter for which the value needs to be checked in the URL",
      "order": 19
    },
    "persistence_cookie_domain": {
      "type": "string",
      "title": "Persistence Cookie Domain",
      "description": "The domain name of the server of a persistency cookie",
      "order": 16
    },
    "persistence_cookie_name": {
      "type": "string",
      "title": "Persistence Cookie Name",
      "description": "The name of the cookie that will be used for persistence",
      "order": 14
    },
    "persistence_cookie_path": {
      "type": "string",
      "title": "Persistence Cookie Path",
      "description": "The path property of the persistency cookie",
      "order": 15
    },
    "persistence_idle_timeout": {
      "type": "integer",
      "title": "Persistence Idle Timeout",
      "description": "The maximum idle time (in seconds) for a persistent connection. A client is directed to the same Real Server unless the connection is inactive for more than the specified number of seconds",
      "order": 12
    },
    "persistence_method": {
      "type": "string",
      "title": "Persistence Method",
      "description": "The Persistence Method to be used to maintain the connection between a client and the first server that it connects to, even when the system is load balancing traffic",
      "order": 10
    },
    "source_ip_netmask": {
      "type": "integer",
      "title": "Source IP Netmask",
      "description": "A subnet mask to make subsequent connections from clients, from the same subnet go to the same Real Server",
      "order": 13
    },
    "status": {
      "type": "string",
      "title": "Status",
      "description": "The status of the content rule",
      "enum": [
        "on",
        "off"
      ],
      "order": 4
    },
    "url_match": {
      "type": "string",
      "title": "URL Match",
      "description": "A URL to be matched to the URL in the request header",
      "order": 7
    },
    "virtual_service_id": {
      "type": "string",
      "title": "Virtual Service ID",
      "description": "Virtual Service ID",
      "order": 1
    },
    "web_firewall_policy": {
      "type": "string",
      "title": "Web Firewall Policy",
      "description": "A web firewall policy to be associated with the content rule",
      "enum": [
        "default",
        "sharepoint",
        "sharepoint2013",
        "owa",
        "owa2010",
        "owa2013",
        "oracle"
      ],
      "order": 5
    }
  },
  "required": [
    "id",
    "lb_algorithm",
    "virtual_service_id"
  ]
}
    """)

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)


class UpdateContentRuleOutput(komand.Output):
    schema = json.loads("""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "id": {
      "type": "string",
      "title": "ID",
      "description": "Content rule ID",
      "order": 1
    }
  },
  "required": [
    "id"
  ]
}
    """)

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)
