# GENERATED BY KOMAND SDK - DO NOT EDIT
import komand
import json


class Component:
    DESCRIPTION = "Start a hunt on clients"


class Input:
    ACTION = "action"
    ANNOTATIONS = "annotations"
    APPLY_PARSERS = "apply_parsers"
    ARTIFACT_LIST = "artifact_list"
    ATTRIBUTE_REGEX = "attribute_regex"
    BYTES_AFTER = "bytes_after"
    BYTES_BEFORE = "bytes_before"
    CH_USERNAME = "ch_username"
    CHECK_CHROME = "check_chrome"
    CHECK_FIREFOX = "check_firefox"
    CHECK_IE = "check_ie"
    CHUNK_SIZE = "chunk_size"
    CLIENT_LIMIT = "client_limit"
    CLIENT_RATE = "client_rate"
    COMPONENT_VERSION = "component_version"
    CONDITIONS = "conditions"
    CONNECTION_STATES = "connection_states"
    CONVERT_VALUES = "convert_values"
    CPU_LIMIT = "cpu_limit"
    CRASH_ALERT_EMAIL = "crash_alert_email"
    DATA_REGEX = "data_regex"
    DEPENDENCIES = "dependencies"
    DESCRIPTION = "description"
    DURATION = "duration"
    EMAIL = "email"
    EMAIL_ADDRESS = "email_address"
    EMAILS_LIMIT = "emails_limit"
    EXPIRY_TIME = "expiry_time"
    EXPORT_FILES_CONTENTS = "export_files_contents"
    EXPORT_FILES_HASHES = "export_files_hashes"
    FETCH_BINARIES = "fetch_binaries"
    FF_USERNAME = "ff_username"
    FIELD = "field"
    FILEFINDER_REGEX = "filefinder_regex"
    FILENAME_REGEX = "filename_regex"
    FLOW_ARGS = "flow_args"
    FLOW_NAME = "flow_name"
    FOLLOW_LINKS = "follow_links"
    FOLLOW_URNS = "follow_urns"
    GET_ARCHIVE = "get_archive"
    GREP_USERS = "grep_users"
    HISTORY_PATH = "history_path"
    HUNT_NAME = "hunt_name"
    IGNORE_INTERPOLATION_ERRORS = "ignore_interpolation_errors"
    INTEGER = "integer"
    KNOWLEDGE_BASE = "knowledge_base"
    LABEL = "label"
    LENGTH = "length"
    LIGHTWEIGHT = "lightweight"
    LISTENING_ONLY = "listening_only"
    LITERAL = "literal"
    LOG_LEVEL = "log_level"
    LOGGING = "logging"
    MATCH_MODE = "match_mode"
    MAX_FILE_SIZE = "max_file_size"
    MAX_FINDINGS = "max_findings"
    MAX_LAST_ACCESS_TIME = "max_last_access_time"
    MAX_LAST_INODE_CHANGE_TIME = "max_last_inode_change_time"
    MAX_LAST_MODIFIED_TIME = "max_last_modified_time"
    MAX_SIZE = "max_size"
    MIN_FILE_SIZE = "min_file_size"
    MIN_LAST_ACCESS_TIME = "min_last_access_time"
    MIN_LAST_INODE_CHANGE_TIME = "min_last_inode_change_time"
    MIN_LAST_MODIFIED_TIME = "min_last_modified_time"
    MODE = "mode"
    NETWORK_BYTES_LIMIT = "network_bytes_limit"
    NOTIFICATION_EVENT = "notification_event"
    NOTIFY_SYSLOG = "notify_syslog"
    ON_NO_RESULTS_ERROR = "on_no_results_error"
    ONLY_CPE = "only_cpe"
    ONLY_LABEL = "only_label"
    ONLY_OS = "only_os"
    OPERATING_SYSTEM = "operating_system"
    OPERATOR = "operator"
    OUTPUT_PLUGIN_NAME = "output_plugin_name"
    OVERSIZED_FILE_POLICY = "oversized_file_policy"
    PATHS = "paths"
    PATHTYPE = "pathtype"
    PRIORITY = "priority"
    PROCESS_NON_REGULAR_FILES = "process_non_regular_files"
    QUEUE = "queue"
    REGEX = "regex"
    RESOLVE_LINKS = "resolve_links"
    RESTRICT_CHECKS = "restrict_checks"
    SPLIT_OUTPUT_BY_ARTIFACT = "split_output_by_artifact"
    START_OFFEST = "start_offest"
    START_OFFSET = "start_offset"
    TABLE_SIGNATURE_LIST = "table_signature_list"
    UPLOAD_TOKEN = "upload_token"
    USE_EXTERNAL_STORES = "use_external_stores"
    USE_TSK = "use_tsk"
    VALUE = "value"
    XDEV = "xdev"
    XOR_IN_KEY = "xor_in_key"
    XOR_OUT_KEY = "xor_out_key"
    

class Output:
    RESULTS = "results"
    

class HuntingInput(komand.Input):
    schema = json.loads("""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "action": {
      "type": "string",
      "title": "Action",
      "description": "Use an action",
      "enum": [
        "STAT",
        "HASH",
        "DOWNLOAD"
      ],
      "order": 36
    },
    "annotations": {
      "type": "array",
      "title": "Annotations",
      "description": "Annotations to add to exported data. This field can be used to differentiate sets of exported data inside a particular exported type. e.g. data collected by users vs. data collected by cronjob",
      "items": {
        "type": "string"
      },
      "order": 95
    },
    "apply_parsers": {
      "type": "boolean",
      "title": "Apply Parsers",
      "description": "If 1, apply any relevant parser to the collected data. If 0, return the raw collected data e.g Files or Registry Keys",
      "order": 21
    },
    "artifact_list": {
      "type": "string",
      "title": "Artifact List",
      "description": "A list of Artifact class names",
      "order": 22
    },
    "attribute_regex": {
      "type": "string",
      "title": "Attribute Regex",
      "description": "The regular expression",
      "order": 83
    },
    "bytes_after": {
      "type": "integer",
      "title": "Bytes After",
      "description": "Include this many bytes after the hit",
      "order": 49
    },
    "bytes_before": {
      "type": "integer",
      "title": "Bytes Before",
      "description": "Include this many bytes before the hit",
      "order": 48
    },
    "ch_username": {
      "type": "string",
      "title": "Chrome History Username",
      "description": "The user to get Chrome history for. If history_path is not set this will be used to guess the path to the history files",
      "order": 14
    },
    "check_chrome": {
      "type": "integer",
      "title": "Check Chrome",
      "description": "Checks Chrome",
      "order": 6
    },
    "check_firefox": {
      "type": "integer",
      "title": "Check Firefox",
      "description": "Checks Chrome",
      "order": 7
    },
    "check_ie": {
      "type": "boolean",
      "title": "Check IE",
      "description": "Checks Internet Explorer",
      "order": 8
    },
    "chunk_size": {
      "type": "integer",
      "title": "Chunk Size",
      "description": "A heartbeat will be emitted every chunk_size.This could be reduced in case the process times out",
      "order": 33
    },
    "client_limit": {
      "type": "integer",
      "title": "Client Limit",
      "description": "Maximum number of clients participating in the hunt. Best practice is for all hunts to use a limit to start with and remove it only when client impact has been assessed by looking at hunt stats. Note that this limit can be overshot by a small number of clients if there are multiple workers running ",
      "order": 75
    },
    "client_rate": {
      "type": "integer",
      "title": "Client Rate",
      "description": "The maximum number of clients to engage per minute. A rate of 0 means to schedule clients as fast as possible",
      "order": 77
    },
    "component_version": {
      "type": "string",
      "title": "Component Version",
      "description": "Version of Chipsec component to be used",
      "order": 30
    },
    "conditions": {
      "type": "string",
      "title": "Conditions",
      "description": "These conditions will be applied to all files that match the path arguments",
      "enum": [
        "MODIFICATION_TIME",
        "ACCESS_TIME",
        "INODE_CHANGE_TIME",
        "SIZE",
        "CONTENTS_REGEX_MATCH",
        "CONTENTS_LITERAL_MATCH",
        "EXT_FLAGS"
      ],
      "order": 37
    },
    "connection_states": {
      "type": "array",
      "title": "Connection States",
      "description": "Network connection states to match. If a process has any network connections in any status listed here, it will be considered a match",
      "items": {
        "type": "string"
      },
      "enum": [
        "UNKNOWN",
        "CLOSED",
        "LISTEN",
        "SYN_SENT",
        "SYN_RECV",
        "ESTABLISHED",
        "FIN_WAIT1",
        "FIN_WAIT2",
        "CLOSE_WAIT",
        "CLOSING",
        "LAST_ACK",
        "TIME_WAIT",
        "DELETE_TCB",
        "NONE",
        "CLOSE"
      ],
      "order": 65
    },
    "convert_values": {
      "type": "boolean",
      "title": "Convert Values",
      "description": "If true, convert values for export-friendly format",
      "order": 94
    },
    "cpu_limit": {
      "type": "integer",
      "title": "CPU Limit",
      "description": "A limit on the client CPU seconds used by this flow",
      "order": 73
    },
    "crash_alert_email": {
      "type": "string",
      "title": "Crash Alert Email",
      "description": "An email address to send mails to when a client crashes during execution of this hunt",
      "order": 78
    },
    "data_regex": {
      "type": "string",
      "title": "Data Regex",
      "description": "A regular expression to search for",
      "order": 9
    },
    "dependencies": {
      "type": "string",
      "title": "Dependencies",
      "description": "Specifies how dependencies should be handled",
      "default": "Use the knowledgebase as a cache. If knowledgebase isn't present, a new one will be populated",
      "enum": [
        "USE_CACHED (default)",
        "IGNORE_DEPS",
        "FETCH_NOW"
      ],
      "order": 23
    },
    "description": {
      "type": "string",
      "title": "Description",
      "description": "The description of this hunt",
      "order": 69
    },
    "duration": {
      "type": "boolean",
      "title": "Duration",
      "description": "Until when should the client stay in the fast poll mode",
      "default": 3600,
      "order": 4
    },
    "email": {
      "type": "string",
      "title": "Email",
      "description": "Email address to send to. If not set, mail will be sent to the logged in user",
      "order": 5
    },
    "email_address": {
      "type": "string",
      "title": "Email Address",
      "description": "The email address that messages will be sent to",
      "order": 89
    },
    "emails_limit": {
      "type": "integer",
      "title": "Emails Limit",
      "description": "The emails limit",
      "order": 90
    },
    "expiry_time": {
      "type": "integer",
      "title": "Expiry Time",
      "description": "Expiry time for the hunt",
      "order": 76
    },
    "export_files_contents": {
      "type": "boolean",
      "title": "Export Files Contents",
      "description": "If this is true, open files and export their full or partial contents. Note: this may require additional datastore roundtrips and slow down the export process, also exporting file contents may significantly increase size of the exported data",
      "order": 91
    },
    "export_files_hashes": {
      "type": "boolean",
      "title": "Export Files Hashes",
      "description": "If this is true, export hashes when dealing with file-related values. The files won't be hashed during the export, hashes will only be exported if they were collected before the export. This option affects exporting VFSFile and StatEntry RDFValues. This is true by default even though it requires extra datastore roundtrips because it's very useful and users expect the hashes to be there",
      "order": 93
    },
    "fetch_binaries": {
      "type": "boolean",
      "title": "Fetch Binaries",
      "description": "Fetches Binaries",
      "order": 66
    },
    "ff_username": {
      "type": "string",
      "title": "Firefox History Username",
      "description": "The user to get FireFox history for. If history_path is not set this will be used to guess the path to the history files",
      "order": 15
    },
    "field": {
      "type": "string",
      "title": "Field",
      "description": "Field Specification",
      "default": "UNSET",
      "enum": [
        "UNSET",
        "USERNAMES",
        "UNAME",
        "FQDN",
        "HOST_TIPS",
        "CLIENT_NAME",
        "CLIENT_DESCRIPTION",
        "SYSTEM",
        "MAC_ADDRESSES",
        "KERNEL_VERSION",
        "OS_VERSION",
        "OS_RELEASE",
        "CLIENT_LABELS",
        "INSTALL_TIME",
        "CLIENT_VERSION",
        "LAST_BOOT_TIME",
        "CLIENT_CLOCK"
      ],
      "order": 84
    },
    "filefinder_regex": {
      "type": "string",
      "title": "FileFinder Regex",
      "description": "The regular expression which will be used to search",
      "order": 46
    },
    "filename_regex": {
      "type": "string",
      "title": "Filename Regex",
      "description": "Regex used to filter the list of processes",
      "order": 67
    },
    "flow_args": {
      "type": "boolean",
      "title": "Regex Checks",
      "description": "Enable high signal regex checks",
      "default": false,
      "order": 2
    },
    "flow_name": {
      "type": "string",
      "title": "Flow Name",
      "description": "The name of the Flow you want to use",
      "enum": [
        "Interrogate",
        "KeepAlive",
        "OnlineNotification",
        "CacheGrep",
        "ChromeHistory",
        "FirefoxHistory",
        "CheckRunner",
        "ArtifactCollectorFlow",
        "DumpACPITable",
        "DumpFlashImage",
        "FileFinder",
        "GetMBR",
        "ListVolumeShadowCopies",
        "Netstat",
        "ListProcesses",
        "CollectRunKeyBinaries",
        "RegistryFinder"
      ],
      "order": 1
    },
    "follow_links": {
      "type": "boolean",
      "title": "Follow links",
      "description": "Should symbolic links be followed in recursive directory listings",
      "order": 60
    },
    "follow_urns": {
      "type": "boolean",
      "title": "Follow URNs",
      "description": "If this is true, follow urns and try to export not only the urns themselves, but also the data they are pointing to. Note: this may require additional datastore roundtrips and slow down the export process",
      "order": 92
    },
    "get_archive": {
      "type": "boolean",
      "title": "Get Archive",
      "description": "Gets Archived History as well (3 months old)",
      "order": 12
    },
    "grep_users": {
      "type": "string",
      "title": "Grep Users",
      "description": "A list of users to check. Default all users on the system",
      "order": 10
    },
    "history_path": {
      "type": "string",
      "title": "History Path",
      "description": "Path to a profile directory that contains a History file",
      "order": 13
    },
    "hunt_name": {
      "type": "string",
      "title": "Hunt Name",
      "description": "The name of the class implementing the hunt to run",
      "order": 68
    },
    "ignore_interpolation_errors": {
      "type": "boolean",
      "title": "Ignore Interpolation Errors",
      "description": "If true, don't die if %%users.homedir%% and similar fail to expand. It's common on windows for some user attributes to be missing if users have never logged in. Enable this when you have multiple artifacts or paths and want to report partial results",
      "order": 24
    },
    "integer": {
      "type": "boolean",
      "title": "Integer",
      "description": "Integer to trigger this hunt",
      "order": 85
    },
    "knowledge_base": {
      "type": "string",
      "title": "Knowledge Base",
      "description": "An optional knowledge base to use, if not specified we retrieve one from the client object",
      "order": 25
    },
    "label": {
      "type": "array",
      "title": "Label",
      "description": "Label that triggers this hunt",
      "items": {
        "type": "string"
      },
      "order": 80
    },
    "length": {
      "type": "integer",
      "title": "Length",
      "description": "How far (in bytes) into the file to search or the length of the MBR to read",
      "order": 51
    },
    "lightweight": {
      "type": "boolean",
      "title": "Lightweight",
      "description": "Performs a light weight version of the interrogate",
      "order": 3
    },
    "listening_only": {
      "type": "boolean",
      "title": "Listening Only",
      "description": "If set, only listening connections are returned",
      "order": 64
    },
    "literal": {
      "type": "string",
      "title": "Literal",
      "description": "Search for this literal string",
      "order": 52
    },
    "log_level": {
      "type": "integer",
      "title": "Log Level",
      "description": "Set the log level. If set, the log returned will include additional information reported by Chipsec",
      "order": 34
    },
    "logging": {
      "type": "boolean",
      "title": "Logging",
      "description": "If the logging is set to true, the client sends log, including Chipsec's log",
      "order": 31
    },
    "match_mode": {
      "type": "string",
      "title": "Match Mode",
      "description": "Match mode to trigger this hunt",
      "enum": [
        "MATCH_ALL",
        "MATCH_ANY"
      ],
      "order": 79
    },
    "max_file_size": {
      "type": "string",
      "title": "Max File Size",
      "description": "The maximum size of files we will download in bytes, 500MB by default",
      "order": 26
    },
    "max_findings": {
      "type": "integer",
      "title": "Maximize Findings",
      "description": "Summarize checks with more than N individual findings",
      "order": 16
    },
    "max_last_access_time": {
      "type": "integer",
      "title": "Min Last Access Time",
      "description": "File must be accessed before this time",
      "order": 42
    },
    "max_last_inode_change_time": {
      "type": "integer",
      "title": "Max Last Inode Change Time",
      "description": "File's must be changed before this time",
      "order": 44
    },
    "max_last_modified_time": {
      "type": "integer",
      "title": "Max Last Modified Time",
      "description": "File must be modified before this time",
      "order": 40
    },
    "max_size": {
      "type": "integer",
      "title": "Max Size",
      "description": "The maximum size of files",
      "order": 56
    },
    "min_file_size": {
      "type": "integer",
      "title": "Min File Size",
      "description": "Minimum file size in bytes",
      "order": 45
    },
    "min_last_access_time": {
      "type": "integer",
      "title": "Min Last Access Time",
      "description": "File must be accessed after this time",
      "order": 41
    },
    "min_last_inode_change_time": {
      "type": "integer",
      "title": "Min Last Inode Change Time",
      "description": "File's inode must be changed after this time",
      "order": 43
    },
    "min_last_modified_time": {
      "type": "integer",
      "title": "Min Last Modified Time",
      "description": "File must be modified after this time",
      "order": 39
    },
    "mode": {
      "type": "string",
      "title": "Mode",
      "description": "When should searching stop? Stop after one hit or search for all",
      "enum": [
        "FIRST_HIT",
        "ALL_HITS"
      ],
      "order": 47
    },
    "network_bytes_limit": {
      "type": "integer",
      "title": "Network Bytes Limit",
      "description": "A limit on the total traffic used by this flow",
      "order": 74
    },
    "notification_event": {
      "type": "string",
      "title": "Notification Event",
      "description": "An event name for an event listener. An event will be published to this listener once the flow finishes",
      "order": 71
    },
    "notify_syslog": {
      "type": "boolean",
      "title": "Notify Syslog",
      "description": "If true, a message will be written by the client to the syslog before running the action. This can be used for debugging in case the client crashes ",
      "order": 35
    },
    "on_no_results_error": {
      "type": "boolean",
      "title": "Oh No Results Error",
      "description": "The maximum size of files we will download in bytes, 500MB by default",
      "order": 27
    },
    "only_cpe": {
      "type": "string",
      "title": "Only CPE",
      "description": "Limit checks to hosts with cpe strings",
      "order": 17
    },
    "only_label": {
      "type": "string",
      "title": "Only CPE",
      "description": "Limit checks to hosts with label strings",
      "order": 18
    },
    "only_os": {
      "type": "string",
      "title": "Only OS",
      "description": "Limit checks to hosts of OS type(s) [Linux|OSX|Windows]",
      "order": 19
    },
    "operating_system": {
      "type": "string",
      "title": "Operating System",
      "description": "Type of operating system to trigger this hunt",
      "enum": [
        "Os_windows",
        "Os_linux",
        "Os_darwin"
      ],
      "order": 81
    },
    "operator": {
      "type": "string",
      "title": "Operator",
      "description": "Operator",
      "enum": [
        "EQUAL",
        "LESS_THAN",
        "GREATER_THAN"
      ],
      "order": 86
    },
    "output_plugin_name": {
      "type": "string",
      "title": "Output Plugin Name",
      "description": "The name of the output plugin",
      "enum": [
        "EmailOutput",
        "BigQueryOutput"
      ],
      "order": 88
    },
    "oversized_file_policy": {
      "type": "string",
      "title": "Max Size",
      "description": "What should GRR do with files that are larger than max_size",
      "enum": [
        "SKIP",
        "HASH_TRUNCATED",
        "DOWNLOAD_TRUNCATED"
      ],
      "order": 57
    },
    "paths": {
      "type": "string",
      "title": "Paths",
      "description": "A path to glob that can contain %% expansions",
      "order": 38
    },
    "pathtype": {
      "type": "string",
      "title": "Path Type",
      "description": "Type of path access to use",
      "enum": [
        "UNSET",
        "OS",
        "TSK",
        "Registry",
        "Memory",
        "TMPFILE"
      ],
      "order": 11
    },
    "priority": {
      "type": "string",
      "title": "Priority",
      "description": "The priority used for this flow",
      "enum": [
        "LOW_PRIORITY",
        "MEDIUM_PRIORITY",
        "HIGH_PRIORITY"
      ],
      "order": 70
    },
    "process_non_regular_files": {
      "type": "boolean",
      "title": "Process Non Regular Files",
      "description": "Look both into regular files and non-regular files (devices, named pipes, sockets). NOTE: This is very dangerous and should be used with care",
      "order": 61
    },
    "queue": {
      "type": "string",
      "title": "Queue",
      "description": "The queue to use for the hunt",
      "order": 72
    },
    "regex": {
      "type": "boolean",
      "title": "Regex",
      "description": "Use a regular expression to trigger this hunt",
      "order": 82
    },
    "resolve_links": {
      "type": "boolean",
      "title": "Resolve links",
      "description": "If true, the action will yield stat information for link targets, if false, the stat for the link itself will be returned",
      "order": 59
    },
    "restrict_checks": {
      "type": "string",
      "title": "Restrict Checks",
      "description": "Only run checks with the specified check_ids",
      "order": 20
    },
    "split_output_by_artifact": {
      "type": "boolean",
      "title": "Split Output by Artifact",
      "description": "If True, use output as a directory and write a separate collection for each artifact collected",
      "order": 28
    },
    "start_offest": {
      "type": "integer",
      "title": "Start Offset",
      "description": "Start searching at this file offset",
      "order": 50
    },
    "start_offset": {
      "type": "integer",
      "title": "Start offset",
      "description": "Start searching at this file offset",
      "order": 53
    },
    "table_signature_list": {
      "type": "string",
      "title": "Table Signature Lists",
      "description": "Signature of ACPI tables to be dumped",
      "order": 32
    },
    "upload_token": {
      "type": "boolean",
      "title": "Upload Token",
      "description": "An upload token to use with the direct upload functionality. This token contains the hmac authenticated policy that determines for how long the client is allowed to upload files to the server. This is comparable to the policy document used by GCS: https://cloud.google.com/storage/docs/xml-api/post-object#policydocument",
      "order": 63
    },
    "use_external_stores": {
      "type": "boolean",
      "title": "Use External Stores",
      "description": "If true, look in any defined external file stores for files before downloading them, and offer any new files to external stores. This should be true unless the external checks are misbehaving",
      "order": 58
    },
    "use_tsk": {
      "type": "boolean",
      "title": "Use TSK",
      "description": "Whether raw filesystem access should be used",
      "order": 29
    },
    "value": {
      "type": "integer",
      "title": "Value",
      "description": "Value",
      "order": 87
    },
    "xdev": {
      "type": "string",
      "title": "Xdev",
      "description": "Behavior when ecountering device boundaries while doing recursive searches",
      "enum": [
        "NEVER",
        "ALWAYS",
        "LOCAL"
      ],
      "order": 62
    },
    "xor_in_key": {
      "type": "integer",
      "title": "XOR in Key",
      "description": "When searching memory we need to ensure we dont hit on our own process. This allows us to obfuscate the search string in memory to avoid us finding ourselves",
      "order": 54
    },
    "xor_out_key": {
      "type": "integer",
      "title": "XOR in Key",
      "description": "When searching memory we need to ensure we dont hit on our own process. This allows us to obfuscate the search string in memory to avoid us finding ourselves",
      "order": 55
    }
  },
  "required": [
    "flow_name"
  ]
}
    """)

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)


class HuntingOutput(komand.Output):
    schema = json.loads("""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "results": {
      "type": "string",
      "title": "Results",
      "description": "Issues found with TruffleHog",
      "order": 1
    }
  }
}
    """)

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)
