package triggers

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/rapid7/komand-plugin-sdk-go2/dispatcher"
	plog "github.com/rapid7/komand-plugin-sdk-go2/log"
	"github.com/rapid7/komand-plugin-sdk-go2/message"

	"github.com/rapid7/komand-plugins/syslog_listener/connection"
)

// ListenTriggerCustomLooper is an interface you can implement to override RunLoop behavior
type ListenTriggerCustomLooper interface {
	RunLoopCustom(ctx context.Context, conn *connection.Connection, input *ListenTriggerInput, log plog.Logger) error
}

// ListenTriggerInputFacilityNone is an enumerated value
const ListenTriggerInputFacilityNone = "None"

// ListenTriggerInputFacilityKERN is an enumerated value
const ListenTriggerInputFacilityKERN = "KERN"

// ListenTriggerInputFacilityUSER is an enumerated value
const ListenTriggerInputFacilityUSER = "USER"

// ListenTriggerInputFacilityMAIL is an enumerated value
const ListenTriggerInputFacilityMAIL = "MAIL"

// ListenTriggerInputFacilityDAEMON is an enumerated value
const ListenTriggerInputFacilityDAEMON = "DAEMON"

// ListenTriggerInputFacilityAUTH is an enumerated value
const ListenTriggerInputFacilityAUTH = "AUTH"

// ListenTriggerInputFacilitySYSLOG is an enumerated value
const ListenTriggerInputFacilitySYSLOG = "SYSLOG"

// ListenTriggerInputFacilityLPR is an enumerated value
const ListenTriggerInputFacilityLPR = "LPR"

// ListenTriggerInputFacilityNEWS is an enumerated value
const ListenTriggerInputFacilityNEWS = "NEWS"

// ListenTriggerInputFacilityUUCP is an enumerated value
const ListenTriggerInputFacilityUUCP = "UUCP"

// ListenTriggerInputFacilityCRON is an enumerated value
const ListenTriggerInputFacilityCRON = "CRON"

// ListenTriggerInputFacilityAUTHPRIV is an enumerated value
const ListenTriggerInputFacilityAUTHPRIV = "AUTHPRIV"

// ListenTriggerInputFacilityFTP is an enumerated value
const ListenTriggerInputFacilityFTP = "FTP"

// ListenTriggerInputFacilityLOCAL0 is an enumerated value
const ListenTriggerInputFacilityLOCAL0 = "LOCAL0"

// ListenTriggerInputFacilityLOCAL1 is an enumerated value
const ListenTriggerInputFacilityLOCAL1 = "LOCAL1"

// ListenTriggerInputFacilityLOCAL2 is an enumerated value
const ListenTriggerInputFacilityLOCAL2 = "LOCAL2"

// ListenTriggerInputFacilityLOCAL3 is an enumerated value
const ListenTriggerInputFacilityLOCAL3 = "LOCAL3"

// ListenTriggerInputFacilityLOCAL4 is an enumerated value
const ListenTriggerInputFacilityLOCAL4 = "LOCAL4"

// ListenTriggerInputFacilityLOCAL5 is an enumerated value
const ListenTriggerInputFacilityLOCAL5 = "LOCAL5"

// ListenTriggerInputFacilityLOCAL6 is an enumerated value
const ListenTriggerInputFacilityLOCAL6 = "LOCAL6"

// ListenTriggerInputFacilityLOCAL7 is an enumerated value
const ListenTriggerInputFacilityLOCAL7 = "LOCAL7"

// ListenTriggerInputLevelNone is an enumerated value
const ListenTriggerInputLevelNone = "None"

// ListenTriggerInputLevelEMERG is an enumerated value
const ListenTriggerInputLevelEMERG = "EMERG"

// ListenTriggerInputLevelALERT is an enumerated value
const ListenTriggerInputLevelALERT = "ALERT"

// ListenTriggerInputLevelCRIT is an enumerated value
const ListenTriggerInputLevelCRIT = "CRIT"

// ListenTriggerInputLevelERR is an enumerated value
const ListenTriggerInputLevelERR = "ERR"

// ListenTriggerInputLevelWARNING is an enumerated value
const ListenTriggerInputLevelWARNING = "WARNING"

// ListenTriggerInputLevelNOTICE is an enumerated value
const ListenTriggerInputLevelNOTICE = "NOTICE"

// ListenTriggerInputLevelINFO is an enumerated value
const ListenTriggerInputLevelINFO = "INFO"

// ListenTriggerInputLevelDEBUG is an enumerated value
const ListenTriggerInputLevelDEBUG = "DEBUG"

// ListenTriggerInputTransportTCP is an enumerated value
const ListenTriggerInputTransportTCP = "TCP"

// ListenTriggerInputTransportUDP is an enumerated value
const ListenTriggerInputTransportUDP = "UDP"

// Output Enums
// ListenTriggerOutputFacilityKERN is an enumerated value
const ListenTriggerOutputFacilityKERN = "KERN"

// ListenTriggerOutputFacilityUSER is an enumerated value
const ListenTriggerOutputFacilityUSER = "USER"

// ListenTriggerOutputFacilityMAIL is an enumerated value
const ListenTriggerOutputFacilityMAIL = "MAIL"

// ListenTriggerOutputFacilityDAEMON is an enumerated value
const ListenTriggerOutputFacilityDAEMON = "DAEMON"

// ListenTriggerOutputFacilityAUTH is an enumerated value
const ListenTriggerOutputFacilityAUTH = "AUTH"

// ListenTriggerOutputFacilitySYSLOG is an enumerated value
const ListenTriggerOutputFacilitySYSLOG = "SYSLOG"

// ListenTriggerOutputFacilityLPR is an enumerated value
const ListenTriggerOutputFacilityLPR = "LPR"

// ListenTriggerOutputFacilityNEWS is an enumerated value
const ListenTriggerOutputFacilityNEWS = "NEWS"

// ListenTriggerOutputFacilityUUCP is an enumerated value
const ListenTriggerOutputFacilityUUCP = "UUCP"

// ListenTriggerOutputFacilityCRON is an enumerated value
const ListenTriggerOutputFacilityCRON = "CRON"

// ListenTriggerOutputFacilityAUTHPRIV is an enumerated value
const ListenTriggerOutputFacilityAUTHPRIV = "AUTHPRIV"

// ListenTriggerOutputFacilityFTP is an enumerated value
const ListenTriggerOutputFacilityFTP = "FTP"

// ListenTriggerOutputFacilityLOCAL0 is an enumerated value
const ListenTriggerOutputFacilityLOCAL0 = "LOCAL0"

// ListenTriggerOutputFacilityLOCAL1 is an enumerated value
const ListenTriggerOutputFacilityLOCAL1 = "LOCAL1"

// ListenTriggerOutputFacilityLOCAL2 is an enumerated value
const ListenTriggerOutputFacilityLOCAL2 = "LOCAL2"

// ListenTriggerOutputFacilityLOCAL3 is an enumerated value
const ListenTriggerOutputFacilityLOCAL3 = "LOCAL3"

// ListenTriggerOutputFacilityLOCAL4 is an enumerated value
const ListenTriggerOutputFacilityLOCAL4 = "LOCAL4"

// ListenTriggerOutputFacilityLOCAL5 is an enumerated value
const ListenTriggerOutputFacilityLOCAL5 = "LOCAL5"

// ListenTriggerOutputFacilityLOCAL6 is an enumerated value
const ListenTriggerOutputFacilityLOCAL6 = "LOCAL6"

// ListenTriggerOutputFacilityLOCAL7 is an enumerated value
const ListenTriggerOutputFacilityLOCAL7 = "LOCAL7"

// Output Enums
// ListenTriggerOutputLevelEMERG is an enumerated value
const ListenTriggerOutputLevelEMERG = "EMERG"

// ListenTriggerOutputLevelALERT is an enumerated value
const ListenTriggerOutputLevelALERT = "ALERT"

// ListenTriggerOutputLevelCRIT is an enumerated value
const ListenTriggerOutputLevelCRIT = "CRIT"

// ListenTriggerOutputLevelERR is an enumerated value
const ListenTriggerOutputLevelERR = "ERR"

// ListenTriggerOutputLevelWARNING is an enumerated value
const ListenTriggerOutputLevelWARNING = "WARNING"

// ListenTriggerOutputLevelNOTICE is an enumerated value
const ListenTriggerOutputLevelNOTICE = "NOTICE"

// ListenTriggerOutputLevelINFO is an enumerated value
const ListenTriggerOutputLevelINFO = "INFO"

// ListenTriggerOutputLevelDEBUG is an enumerated value
const ListenTriggerOutputLevelDEBUG = "DEBUG"

// ListenTriggerInput defines the input for the ListenTrigger
type ListenTriggerInput struct {
	CustomListenTriggerInputParams
	Endpoint  string `json:"endpoint"`
	Facility  string `json:"facility"`
	Filter    string `json:"filter"`
	Level     string `json:"level"`
	Port      int    `json:"port"`
	Transport string `json:"transport"`
}

// ListenTriggerOutput defines the output for the ListenTrigger
type ListenTriggerOutput struct {
	Facility string `json:"facility"`
	Host     string `json:"host"`
	Level    string `json:"level"`
	Msg      string `json:"msg"`
	Msgid    string `json:"msgid"`
	Proc     string `json:"proc"`
}

// ListenTrigger a trigger
type ListenTrigger struct {
	queue      chan *ListenTriggerOutput
	dispatcher dispatcher.Dispatcher
	meta       json.RawMessage
}

// NewListenTrigger returns a new ListenTrigger properly initialized and ready to run.
func NewListenTrigger(d dispatcher.Dispatcher, meta json.RawMessage) *ListenTrigger {
	return &ListenTrigger{
		queue:      make(chan *ListenTriggerOutput, 1),
		dispatcher: d,
		meta:       meta,
	}
}

// Send will submit a ListenTriggerOutput onto the internal queue, which then buffers to the external queue
func (t *ListenTrigger) Send(o interface{}) {
	t.queue <- o.(*ListenTriggerOutput)
}

// Stop will close the internal queue, which will prevent new jobs from entering.
func (t *ListenTrigger) Stop() {
	close(t.queue)
}

// RunLoop runs the trigger and blocks until the trigger polling is complete or errors. It will block.
// TODO This could be optimized so that the "instant tick" idiom is only used when the ticker is used
// It would take more work but it would be a definite improvement. Also this does mean the first iteration
// of the loop will ignore a cancelletion from the context, but at this time i am willing to accept that tradeoff
// since this helps the more likely case of a message being lost on sudden shutdown.
func (t *ListenTrigger) RunLoop(ctx context.Context, conn *connection.Connection, input *ListenTriggerInput, log plog.Logger) error {
	// Trigger inputs only get sent in once. Before we event bother with this loop stuff, check it
	// Bail if it's invalid
	var err error
	for _, err = range input.Validate(log) {
		log.Errorf("Error while validating ListenTriggerInput: %s\n", err.Error())
	}
	if err != nil {
		return fmt.Errorf("Error while validating ListenTriggerInput. Check logs for details")
	}
	// This timer idiom is a bit odd - it is the "instant tick" idiom
	// Basically, i don't need to wait for the first iteration of the timer for it to fire
	// it fires immediately, then every duration thereafter.
	// See: https://www.reddit.com/r/golang/comments/5g0hor/ticker_with_instant_start/daoxqey/
	// You will only see a ticker here if the Trigger defined the "Interval" field, otherwise this is a vanilla for{select{}}
	for {
		output, err := t.Run(conn, input, log)
		if err != nil {
			log.Errorf("Error while running trigger action for ListenTrigger: %s\n", err.Error())
			continue
		}
		t.Send(output) // Leave this untouched line, it will submit the trigger output to the Komand system.

		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			// Loop back to the top, polling and submitting another message
			continue
		}
	}
}

// ReadLoop will block, reading until a nil message is received, meaning the internal queue was closed
func (t *ListenTrigger) ReadLoop(ctx context.Context, log plog.Logger) error {
	for {
		select {
		case output := <-t.queue:
			if output == nil {
				// The channel was closed, we got an empty-closed-read, so we bail out with no issues
				return nil
			}
			response := message.TriggerEvent{
				Type:    "", // We did not set the type in the SDK before, seems to only be for testing or legacy needs
				ID:      "", // We did not set the ID in the SDK before
				GroupID: "", // We did not set the GroupID in the SDK before
				Output:  output,
				Meta:    t.meta, // Copy the incoming meta to pass it along to the outgoing message
			}
			m := message.V1{
				Version: "v1",
				Type:    "trigger_event",
				Body:    &response,
			}
			// Send the message to the komand system
			if err := t.dispatcher.Send(m); err != nil {
				log.Errorf("Receieved error sending trigger message: %s\n", err)
				return err
			}
		case <-ctx.Done():
			// We check this AFTER the queue, because the publish end of this loop needs to stop submitting
			// things to the trigger, then we make sure we've drained that channel, then we can stop.
			// We don't want to quit with a message still in the pipe, lest it be lost.
			// We're done, bailout
			return ctx.Err()
		}
	}
}
