import insightconnect_plugin_runtime
import time


from .schema import VulnerabilityUpdatedInput, VulnerabilityUpdatedOutput, Input, Output, Component
from typing import Dict, Any, List, Generator, Tuple
from icon_servicenow.util.constants import MAXIMUM_NUMBER_OF_REQUESTS, PAGINATION_OFFSET


class VulnerabilityUpdated(insightconnect_plugin_runtime.Trigger):
    def __init__(self):
        super(self.__class__, self).__init__(
            name="vulnerability_updated",
            description=Component.DESCRIPTION,
            input=VulnerabilityUpdatedInput(),
            output=VulnerabilityUpdatedOutput(),
        )

    def run(self, params={}):
        # START INPUT BINDING - DO NOT REMOVE - ANY INPUTS BELOW WILL UPDATE WITH YOUR PLUGIN SPEC AFTER REGENERATION
        interval = params.get(Input.INTERVAL, 5)
        monitored_fields = params.get(Input.MONITORED_FIELDS, "")
        system_ids = params.get(Input.SYSTEM_IDS, [])
        # END INPUT BINDING - DO NOT REMOVE

        # Initial pull of all the vulnerabilities with conversion generators to dict.
        # We need to store all of them in memory for the comparison.
        previous_vuls = dict(self.get_all_vuls(monitored_fields, system_ids=system_ids))

        while True:
            # Pull all the incidents
            current_vuls = self.get_all_vuls(monitored_fields, system_ids=system_ids)

            # Compare previous and new incident results. Using dict to speed up compute time.
            # After comparison the previous_incidents variable is being updated to current_incidents
            for key, value in current_vuls:
                if key in previous_vuls and value != previous_vuls.get(key):
                    if changed_fields := self._parse_new_fields(value, previous_vuls.get(key, {})):
                        self.send({Output.SYSTEM_ID: key, Output.CHANGED_FIELDS: changed_fields})
                previous_vuls[key] = value

            # Sleep for configured frequency in minutes
            self.logger.info(f"Sleeping for {interval} seconds...")
            time.sleep(interval)

    def get_all_vuls(
        self, monitored_fields: str, system_ids: List[str] = None, **kwargs
    ) -> Generator[Tuple[str, Dict[str, Any]], Any, None]:
        """
        Get all the vulnerabilities from API. Uses offset to get data from all pages.

        :param monitored_fields: Field names to be monitored separated by comma.
        :type: str

        :param system_ids: List of system IDs. That parameter is optional. If not set defaults to all incidents pulled.
        :type: List[str]

        :return: A generator that yields a tuple consisting of a string and a dictionary.
        :rtype: Generator[Tuple[str, Dict[str, Any]], Any, None]
        """

        query = "ORDERBYDESCsys_created_on"
        if system_ids:
            query = "^OR".join(list(map(lambda system_id: f"sys_id={system_id}", system_ids))) + f"^{query}"

        vuls = []
        for offset in range(0, MAXIMUM_NUMBER_OF_REQUESTS * PAGINATION_OFFSET, PAGINATION_OFFSET):
            if new_vuls := (
                self.connection.request.make_request(
                    self.connection.vulnerability_url,
                    "GET",
                    params={
                        "sysparm_limit": PAGINATION_OFFSET,
                        "sysparm_fields": f"sys_id,{monitored_fields}",
                        "sysparm_query": query,
                        "sysparm_offset": offset,
                    },
                    **kwargs,
                )
                .get("resource", {})
                .get("result", [])
            ):
                vuls.extend(new_vuls)
            else:
                break
        return self._generate_results(vuls)

    @staticmethod
    def _parse_new_fields(current_vul: Dict[str, Any], previous_vul: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parses and returns a dictionary containing the changed fields in the current vulnerability
        compared to the previous vulnerability.

        :param current_vul: A dictionary representing the current vulnerability.
        :type: Dict[str, Any]

        :param previous_vul: A dictionary representing the previous vulnerability.
        :type: Dict[str, Any]

        :return: A dictionary containing the new fields in the current vulnerability.
        :rtype: Dict[str, Any]
        """

        changed_fields = {}
        for key, value in current_vul.items():
            previous_vul_value = previous_vul.get(key)
            if value != previous_vul_value:
                changed_fields[key] = {
                    "current": value,
                    "previous": previous_vul_value,
                }
        return changed_fields

    @staticmethod
    def _generate_results(list_of_vuls: List[Dict[str, Any]]) -> Generator[Tuple[str, Dict[str, Any]], Any, None]:
        """
        Generate results based on the list of vulnerabilities.

        This method takes a list of vulnerabilities as input and generates results based on the provided vulnerabilities.
        It returns a generator that yields a tuple consisting of a string and a dictionary. The solution
        was made in order to save the memory during trigger runtime.

        :param list_of_vuls: A list of vulnerabilities represented as dictionaries.
        :type: List[Dict[str, Any]]

        :return: A generator that yields a tuple consisting of a string and a dictionary.
        :rtype: Generator[Tuple[str, Dict[str, Any]], Any, None]
        """

        return ((vul.pop("sys_id", ""), vul) for vul in list_of_vuls)
