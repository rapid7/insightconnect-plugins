# GENERATED BY INSIGHT-PLUGIN - DO NOT EDIT
import insightconnect_plugin_runtime
import json


class Component:
    DESCRIPTION = "Create a blocked sender policy"


class Input:
    DESCRIPTION = "description"
    FROM_PART = "from_part"
    FROM_TYPE = "from_type"
    FROM_VALUE = "from_value"
    OPTION = "option"
    SOURCE_IPS = "source_ips"
    TO_TYPE = "to_type"
    TO_VALUE = "to_value"


class Output:
    SENDER_POLICY = "sender_policy"


class CreateBlockedSenderPolicyInput(insightconnect_plugin_runtime.Input):
    schema = json.loads(
        r"""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "description": {
      "type": "string",
      "title": "Description",
      "description": "A description for the policy which is kept with the email in the archive for future reference",
      "order": 2
    },
    "from_part": {
      "type": "string",
      "title": "From Part",
      "description": "Must be: envelope_from, header_from or both",
      "default": "envelope_from",
      "enum": [
        "envelope_from",
        "header_from",
        "both"
      ],
      "order": 3
    },
    "from_type": {
      "type": "string",
      "title": "From Type",
      "description": "Can be one of: everyone, internal_addresses, external_addresses, email_domain, profile_group or individual_email_address",
      "default": "individual_email_address",
      "enum": [
        "everyone",
        "internal_addresses",
        "external_addresses",
        "email_domain",
        "profile_group",
        "individual_email_address"
      ],
      "order": 4
    },
    "from_value": {
      "type": "string",
      "title": "From Value",
      "description": "Required if `From Type` is one of email_domain, profile_group, individual_email_address. Expected values: If `From Type` is email_domain, a domain name without the @ symbol. If `From Type` is profile_group, the ID of the profile group. If `From Type` is individual_email_address, an email address",
      "order": 5
    },
    "option": {
      "type": "string",
      "title": "Option",
      "description": "The block, option must be: no_action or block_sender",
      "default": "block_sender",
      "enum": [
        "block_sender",
        "no_action"
      ],
      "order": 1
    },
    "source_ips": {
      "type": "string",
      "title": "Source IPs",
      "description": "A comma separated list of IP addresses using CIDR notation (X.X.X.X/XX). When set the policy only applies for connections from matching addresses",
      "order": 8
    },
    "to_type": {
      "type": "string",
      "title": "To Type",
      "description": "Can be one of: everyone, internal_addresses, external_addresses, email_domain, profile_group or individual_email_address",
      "default": "individual_email_address",
      "enum": [
        "everyone",
        "internal_addresses",
        "external_addresses",
        "email_domain",
        "profile_group",
        "individual_email_address"
      ],
      "order": 6
    },
    "to_value": {
      "type": "string",
      "title": "To Value",
      "description": "Required if `To Type` is one of email_domain, profile_group, individual_email_address. Expected values: If `To Type` is email_domain, a domain name without the @ symbol. If `To Type` is profile_group, the ID of the profile group. If `To Type` is individual_email_address, an email address",
      "order": 7
    }
  },
  "required": [
    "description",
    "from_part",
    "from_type",
    "option",
    "to_type"
  ],
  "definitions": {}
}
    """
    )

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)


class CreateBlockedSenderPolicyOutput(insightconnect_plugin_runtime.Output):
    schema = json.loads(
        r"""
   {
  "type": "object",
  "title": "Variables",
  "properties": {
    "sender_policy": {
      "type": "array",
      "title": "Policy",
      "description": "The policy that was created",
      "items": {
        "$ref": "#/definitions/sender_policy"
      },
      "order": 1
    }
  },
  "definitions": {
    "sender_policy": {
      "type": "object",
      "title": "sender_policy",
      "properties": {
        "id": {
          "type": "string",
          "title": "ID",
          "description": "The Mimecast ID of the policy. Used when updating the policy",
          "order": 1
        },
        "option": {
          "type": "string",
          "title": "Option",
          "description": "The option set for the policy. Will be one of no_action, block_sender",
          "order": 2
        },
        "policy": {
          "$ref": "#/definitions/policy",
          "title": "Policy",
          "description": "The policy that was created",
          "order": 3
        }
      }
    },
    "policy": {
      "type": "object",
      "title": "policy",
      "properties": {
        "fromEternal": {
          "type": "boolean",
          "title": "From Eternal",
          "description": "If the policy is always applied or if there is a specific start date",
          "order": 1
        },
        "toDate": {
          "type": "string",
          "title": "To Date",
          "description": "The date that the policy will apply until",
          "order": 2
        },
        "fromValue": {
          "type": "string",
          "title": "From Value",
          "description": "A value defining which senders the policy applies to",
          "order": 3
        },
        "from": {
          "type": "object",
          "title": "From",
          "description": "An object containing type and value fields defining which sender addresses the policy applies to",
          "order": 4
        },
        "description": {
          "type": "string",
          "title": "Description",
          "description": "The description for the policy which is kept with the email in the archive for future reference",
          "order": 5
        },
        "bidirectional": {
          "type": "boolean",
          "title": "Bidirectional",
          "description": "If the policy is also applied in the reverse of the email flow, i.e. where the specified recipient in the policy becomes the sender, and the specified sender in the policy becomes the recipient",
          "order": 6
        },
        "fromType": {
          "type": "string",
          "title": "From Type",
          "description": "Which sender addresses the policy applies to. Can be one of everyone, internal_addresses, external_addresses, email_domain, profile_group, address_attribute_value, individual_email_address, free_mail_domains, header_display_name",
          "order": 7
        },
        "to": {
          "type": "object",
          "title": "To",
          "description": "An object containing type and value fields defining which recipient addresses the policy applies to",
          "order": 8
        },
        "fromDate": {
          "type": "string",
          "title": "From Date",
          "description": "The date that the policy will apply from",
          "order": 9
        },
        "override": {
          "type": "boolean",
          "title": "Override",
          "description": "If true, this option overrides the order in which the policy is applied, and forces it to be applied first if there are multiple applicable policies, unless more specific policies of the same type have been configured with an override as well",
          "order": 10
        },
        "toEternal": {
          "type": "boolean",
          "title": "To Eternal",
          "description": "If the policy should always be applied or if there is an end date",
          "order": 11
        },
        "conditions": {
          "type": "object",
          "title": "Conditions",
          "description": "An object with fields describing additional conditions that should affect when the policy is applied",
          "order": 12
        },
        "toType": {
          "type": "string",
          "title": "To Type",
          "description": "Which recipient addresses the policy applies to. Can be one of everyone, internal_addresses, external_addresses, email_domain, profile_group, address_attribute_value, individual_email_address, free_mail_domains, header_display_name",
          "order": 13
        },
        "fromPart": {
          "type": "string",
          "title": "From Part",
          "description": "Which from address is used in the policy. Can be any of envelope_from, header_from, both",
          "order": 14
        }
      }
    }
  }
}
    """
    )

    def __init__(self):
        super(self.__class__, self).__init__(self.schema)
