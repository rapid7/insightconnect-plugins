package main

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/rapid7/komand-plugin-sdk-go2/cli"
	plog "github.com/rapid7/komand-plugin-sdk-go2/log"
	"github.com/rapid7/komand-plugin-sdk-go2/message"
	"github.com/rapid7/komand-plugins/office365/actions"
	"github.com/rapid7/komand-plugins/office365/connection"
	"github.com/rapid7/komand-plugins/office365/server/http"
	"github.com/rapid7/komand-plugins/office365/triggers"
	kingpin "gopkg.in/alecthomas/kingpin.v2"
)

var (
	// Name plugin name
	Name = "office365"
	// Vendor plugin vendor
	Vendor = "rapid7"
	// Version plugin version
	Version = "2.0.4"
	// Description plugin description
	Description = "Access Outlook mailboxes in Office 365"
	// DefaultPort is the default port to use
	DefaultPort = "10001"
)

// getMessageFromStdin looks through both stdin and the os.Args for a message body to work as input
func getMessageFromStdin() (*message.V1, *message.BodyV1, error) {
	b := &message.BodyV1{}
	m := &message.V1{
		Body: b, // Seed it with a type so marshalling works
	}
	dec := json.NewDecoder(os.Stdin)
	if err := dec.Decode(m); err != nil {
		// Try from os.Args[3] which is where the komand engine code will send the data
		// when it's not over stdin - this will always have a "--" in pos 2
		if len(os.Args) == 4 && os.Args[2] == "--" {
			if err := json.Unmarshal([]byte(os.Args[3]), m); err != nil {
				return nil, nil, err
			}
			return m, b, nil
		}
		// If it wasn't over stdin, and it wasn't in pos3, following "--" in pos2, it's an error
		return nil, nil, fmt.Errorf("Unable to find message in os.Stdin nor os.Args: %+v", os.Args)
	}
	return m, b, nil
}

func main() {
	app := kingpin.New(Name, Description)
	app.Version(Version)

	debug := app.Flag("debug", "Log events to stdout.").Default("false").Bool()
	test := app.Command("test", "Run a test using the start message over STDIN.")
	info := app.Command("info", "Display plugin info (triggers and actions).")
	sample := app.Command("sample", "Show a sample start message for the provided trigger or action.")
	sampleOpt := sample.Arg("handler_name", "Trigger or Action name to generate sample inputs for.").Required().String()
	run := app.Command("run", "Run the plugin (default command). You must supply the start message over STDIN.")
	httpServer := app.Command("http", "Run the plugin as a REST daemon")
	port := app.Flag("port", "The http port to run the server on (defaults to 10001).").Default(DefaultPort).Int()

	args := os.Args[1:] // Chop off the first element, we don't care about the binary name/path

	// Code lifted from old SDK to make kingpin happy
	for i, argv := range args {
		if argv == "--" {
			args = args[0:(i)]
			break
		}
	}
	if len(args) < 1 || (len(args) == 1 && strings.HasSuffix(args[0], "debug")) {
		args = append(args, "run")
	}
	// End of kingpin happiness making

	// Trap the interrupts
	stopChan := make(chan os.Signal, 1)
	signal.Notify(stopChan, syscall.SIGTERM, syscall.SIGINT)
	// Create a context, which will be used to cancel things like triggers in the event of a signal
	ctx, cancel := context.WithCancel(context.Background())
	// Kick off a goroutine to handle the signals and the cancellation
	go cli.HandleShutdown(cancel, stopChan)
	// Invoke the command

	mode := "run"
	cmd, err := app.Parse(args)
	switch kingpin.MustParse(cmd, err) {
	case sample.FullCommand():
		printSampleInput(*sampleOpt)
	case info.FullCommand():
		printInfo()
	case httpServer.FullCommand():
		s, err := http.NewServer(*port, connection.NewCache())
		if err != nil {
			log.Fatal(err)
		}
		fmt.Printf("Plugin office365 booting HTTP Daemon on port %d...", *port)
		// This will block until the server shuts down
		if err := s.ListenAndServe(); err != nil {
			log.Fatal(err)
		}
	case test.FullCommand():
		mode = "test"
		fallthrough
	case run.FullCommand():
		fallthrough
	default:
		// We're running either an action, or a trigger
		m, b, err := getMessageFromStdin()
		if err != nil {
			log.Fatalf("you must provide a message body via STDIN to run an action or trigger: %s", err.Error())
		}
		switch m.Type {
		case message.ActionStart:
			if err := runOneOffAction(mode, b, *debug); err != nil { // Command should be run, or test
				log.Fatal(err)
			}
		case message.TriggerStart:
			// This will block until the trigger shuts down
			if err := runTriggerDaemon(ctx, mode, b, *debug); err != nil { // Command should be run, or test
				log.Fatal(err)
			}
		default:
			log.Fatalf("unknown message type %s", m.Type)
		}
	}
}

func runOneOffAction(mode string, b *message.BodyV1, isDebug bool) error {
	// Set up all the standard data structures we need to process an action
	cd := &connection.Data{}
	l := plog.NewBufferedLogger(plog.Error)
	if mode == "test" || isDebug {
		l.SetLevel(plog.Info)
	}
	// Actions always default to using STDOUT since we never send dispatch info
	// with their message invocations, but to try and keep things consistent between actions
	// and triggers in the hopes of further generalizing their code, we'll continue
	// to use the method below to make the determination of what to use
	d, err := cli.DispatcherFromRaw(b.Dispatcher, isDebug, mode)
	if err != nil {
		return err
	}
	// Make sure we flush the log out stderr as thats how the engine knows to get it in a one off
	defer l.Flush(os.Stderr)
	response := &message.Response{
		Meta:   []byte(`{}`),
		Status: "ok",
	}
	if err = json.Unmarshal(b.Connection, cd); err != nil {
		return err
	}
	var conn *connection.Connection
	conn, err = connection.Connect(cd, l)
	if err != nil {
		return err
	}
	// Unmarshal the body into the right struct
	// We could avoid the 2 excess json marshal calls in here with a lot of switch-casing on types
	// but in this case, the performance gain is not that great, and it's less generator code to maintain
	// to do it this way.
	// TODO if we suspect this is a bottleneck, profile it and swap back to the switch-case approach
	switch b.Action {
	case "copy_folder":
		input := &actions.CopyFolderInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating CopyFolderTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating CopyFolderTriggerInput. Check logs for details")
		}
		a := &actions.CopyFolderAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "copy_message":
		input := &actions.CopyMessageInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating CopyMessageTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating CopyMessageTriggerInput. Check logs for details")
		}
		a := &actions.CopyMessageAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "create_and_send":
		input := &actions.CreateAndSendInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating CreateAndSendTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating CreateAndSendTriggerInput. Check logs for details")
		}
		a := &actions.CreateAndSendAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "create_attachment":
		input := &actions.CreateAttachmentInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating CreateAttachmentTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating CreateAttachmentTriggerInput. Check logs for details")
		}
		a := &actions.CreateAttachmentAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "create_folder":
		input := &actions.CreateFolderInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating CreateFolderTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating CreateFolderTriggerInput. Check logs for details")
		}
		a := &actions.CreateFolderAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "delete_attachment":
		input := &actions.DeleteAttachmentInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating DeleteAttachmentTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating DeleteAttachmentTriggerInput. Check logs for details")
		}
		a := &actions.DeleteAttachmentAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "delete_folder":
		input := &actions.DeleteFolderInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating DeleteFolderTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating DeleteFolderTriggerInput. Check logs for details")
		}
		a := &actions.DeleteFolderAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "delete_message":
		input := &actions.DeleteMessageInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating DeleteMessageTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating DeleteMessageTriggerInput. Check logs for details")
		}
		a := &actions.DeleteMessageAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "forward_message":
		input := &actions.ForwardMessageInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating ForwardMessageTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating ForwardMessageTriggerInput. Check logs for details")
		}
		a := &actions.ForwardMessageAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "get_attachments":
		input := &actions.GetAttachmentsInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating GetAttachmentsTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating GetAttachmentsTriggerInput. Check logs for details")
		}
		a := &actions.GetAttachmentsAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "get_contacts":
		input := &actions.GetContactsInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating GetContactsTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating GetContactsTriggerInput. Check logs for details")
		}
		a := &actions.GetContactsAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "get_folders":
		input := &actions.GetFoldersInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating GetFoldersTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating GetFoldersTriggerInput. Check logs for details")
		}
		a := &actions.GetFoldersAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "get_messages":
		input := &actions.GetMessagesInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating GetMessagesTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating GetMessagesTriggerInput. Check logs for details")
		}
		a := &actions.GetMessagesAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "most_recently_sent":
		input := &actions.MostRecentlySentInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating MostRecentlySentTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating MostRecentlySentTriggerInput. Check logs for details")
		}
		a := &actions.MostRecentlySentAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "move_folder":
		input := &actions.MoveFolderInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating MoveFolderTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating MoveFolderTriggerInput. Check logs for details")
		}
		a := &actions.MoveFolderAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "move_message":
		input := &actions.MoveMessageInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating MoveMessageTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating MoveMessageTriggerInput. Check logs for details")
		}
		a := &actions.MoveMessageAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	case "reply_to_message":
		input := &actions.ReplyToMessageInput{}
		if err = json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		for _, err = range input.Validate(l) {
			log.Println(fmt.Sprintf("Error while validating ReplyToMessageTriggerInput: %s", err.Error()))
		}
		if err != nil {
			return fmt.Errorf("Error while validating ReplyToMessageTriggerInput. Check logs for details")
		}
		a := &actions.ReplyToMessageAction{}
		runMethod := a.Run
		if mode == "test" {
			runMethod = a.Test
		}
		response.Output, err = runMethod(conn, input, l)
	default:
		return fmt.Errorf("unknown action %s", b.Action)
	}
	if err != nil {
		response.Status = "error"
		response.Error = err.Error()
	}
	response.Log = l.String()
	// dispatch the result
	wrapper := &message.V1{
		Body:    response,
		Type:    "action_event",
		Version: "v1",
	}
	d.Send(wrapper)
	return nil
}

func runTriggerDaemon(ctx context.Context, mode string, b *message.BodyV1, isDebug bool) error {
	// Make a logger
	l := plog.NewNormalLogger(plog.Error)
	if mode == "test" || isDebug {
		l.SetLevel(plog.Info)
	}
	// Serialize the connection data into the raw struct
	cd := &connection.Data{}
	if err := json.Unmarshal(b.Connection, cd); err != nil {
		return err
	}
	// Now, establish a valid connection
	conn, err := connection.Connect(cd, l)
	if err != nil {
		return err
	}
	// Get the dispatcher - will send the messages be sent over stdout or posted over http
	d, err := cli.DispatcherFromRaw(b.Dispatcher, isDebug, mode)
	if err != nil {
		return err
	}
	switch b.Trigger {
	case "new_message":
		// Make the input and serialize it into the struct
		input := &triggers.NewMessageTriggerInput{}
		if err := json.Unmarshal(b.Input, input); err != nil {
			return err
		}
		// Build the trigger
		t := triggers.NewNewMessageTrigger(d, b.Meta)
		if mode == "test" { // Test mode, use the test method
			// Since the test method doesn't need a run or read loop
			// we do the boring work of packaging the result here
			// Invoke the test, pass the results to the message helper func
			// then pass that message into the dispatcher
			o, err := t.Test(conn, input, l)
			d.Send(cli.WrapTriggerTestResult(l, o, err))
			return nil
		}
		// Start the read loop
		go t.ReadLoop(ctx, l)
		var ti interface{} = t
		if cl, ok := ti.(triggers.NewMessageTriggerCustomLooper); ok {
			return cl.RunLoopCustom(ctx, conn, input, l)
		}
		// Run will block until it completes / shutsdown
		return t.RunLoop(ctx, conn, input, l)
	default:
		return fmt.Errorf("unknown trigger %s", b.Trigger)
	}
}

func printInfo() {
	// General Info / Header
	result := "\n"
	result += fmt.Sprintf("Name:        %s%s%s\n", cli.Green, Name, cli.Reset)
	result += fmt.Sprintf("Vendor:      %s%s%s\n", cli.Green, Vendor, cli.Reset)
	result += fmt.Sprintf("Version:     %s%s%s\n", cli.Green, Version, cli.Reset)
	result += fmt.Sprintf("Description: %s%s%s\n", cli.Green, Description, cli.Reset)

	// Trigger Info
	result += fmt.Sprintf("\n")
	result += fmt.Sprintf("Triggers (%s%d%s): \n", cli.Green, 1, cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "new_message", cli.Reset, "Fires when a new message is received in a given folder", cli.Reset)

	// Action Info
	result += fmt.Sprintf("\n")
	result += fmt.Sprintf("Actions (%s%d%s): \n", cli.Green, 17, cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "copy_folder", cli.Reset, "Copy a mailbox folder underneath the given parent", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "copy_message", cli.Reset, "Copy an email message to a folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "create_and_send", cli.Reset, "Create and send a new email message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "create_attachment", cli.Reset, "Create an attachment to the given message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "create_folder", cli.Reset, "Create a new mailbox folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "delete_attachment", cli.Reset, "Delete an attachment to a message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "delete_folder", cli.Reset, "Delete a mailbox folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "delete_message", cli.Reset, "Delete an email message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "forward_message", cli.Reset, "Forward an email message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "get_attachments", cli.Reset, "Get a list of attachments to the given message", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "get_contacts", cli.Reset, "Get a list of contacts for user or principal", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "get_folders", cli.Reset, "Get a list of folders under a given email folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "get_messages", cli.Reset, "Get a list of messages in the given folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "most_recently_sent", cli.Reset, "Get the most recent message in the SentItems folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "move_folder", cli.Reset, "Move a mailbox folder to under a new parent", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "move_message", cli.Reset, "Move an email message to a different folder", cli.Reset)
	result += fmt.Sprintf("└── %s%s%s (%s%s)\n", cli.Green, "reply_to_message", cli.Reset, "Reply to an email message", cli.Reset)

	fmt.Print(result)
}

func printSampleInput(action string) error {
	connBytes, err := json.Marshal(connection.Data{})
	if err != nil {
		return err
	}
	b := &message.BodyV1{
		Action:     action,
		Connection: connBytes,
		Meta:       []byte(`{}`),
		Dispatcher: []byte(`{}`),
	}
	m := message.V1{
		Version: "v1",
		Body:    b,
	}
	switch action {
	case "copy_folder":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.CopyFolderInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "copy_message":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.CopyMessageInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "create_and_send":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.CreateAndSendInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "create_attachment":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.CreateAttachmentInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "create_folder":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.CreateFolderInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "delete_attachment":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.DeleteAttachmentInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "delete_folder":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.DeleteFolderInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "delete_message":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.DeleteMessageInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "forward_message":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.ForwardMessageInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "get_attachments":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.GetAttachmentsInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "get_contacts":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.GetContactsInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "get_folders":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.GetFoldersInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "get_messages":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.GetMessagesInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "most_recently_sent":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.MostRecentlySentInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "move_folder":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.MoveFolderInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "move_message":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.MoveMessageInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "reply_to_message":
		m.Type = "action_start"
		actionBytes, err := json.Marshal(actions.ReplyToMessageInput{})
		if err != nil {
			return err
		}
		b.Input = actionBytes
	case "new_message":
		m.Type = "trigger_start"
		triggerBytes, err := json.Marshal(triggers.NewMessageTriggerInput{})
		if err != nil {
			return err
		}
		b.Input = triggerBytes
	default:
		log.Fatalf("Unknown action or trigger %s", action)
	}

	result, err := json.MarshalIndent(&m, " ", "  ")
	if err != nil {
		return err
	}
	fmt.Println(string(result))
	return nil
}
